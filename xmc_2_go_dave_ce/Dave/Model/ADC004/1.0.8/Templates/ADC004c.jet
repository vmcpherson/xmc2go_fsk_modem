<%@ jet package="CodeGenerator" class="adc004c_template"
imports="java.util.* com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>

/*CODE_BLOCK_BEGIN[ADC004.c]*/

/*******************************************************************************
 Copyright (c) 2013, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC1000 Series                                         **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : DAVE App Developer                                              **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Jan 28, 2014                                           **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                      Author(s) Identity                                    **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** SSAM         DAVE App Developer                                            **
** ---------------------------------------------------------------------------**

*******************************************************************************/


/**
 * @file ADC004.c
 *
 * @brief This file contains ADC004 App API definitions
 * Change History:
 * Date       version       Details
 * 13-Jun-2013  1.0.0     Initial code added for XMC1100
 * 27-Jun-2013  1.0.2     Help doc updated
 *                        Enable Arbitration slot removed from UI
 * 13-Nov-2013  1.0.4     In GUI Group 0/1 is made as Group A/B and
 *                        manifest modified as per this change.
 * 28-Jan-2014  1.0.6     1. New api ADC004_GetFastResult() implemented.
 *                        2. Error codes are added in various functions,
 *                           that can be logged with DBG002 App.
 */

/*******************************************************************************
 ** INCLUDE FILES                                                             **
 ******************************************************************************/
#include <DAVE3.h>

<% String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null;
   boolean DBGApp = false;
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}
//   }
  } %>

<% if (!DBGApp) { %>
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/
#ifndef _DBG002_H_

#define DBG002_MESSAGEID_LITERAL

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e)
#define DBG002_IG(e,g)
#define DBG002_IH(e,h)
#define DBG002_IP(e,p)
#define DBG002_IGH(e,g,h)
#define DBG002_IGP(e,g,p)
#define DBG002_IHP(e,h,p)
#define DBG002_IGHP(e,g,h,p)
#define DBG002_N(e)
#define DBG002_NG(e,g)
#define DBG002_NH(e,h)
#define DBG002_NP(e,p)
#define DBG002_NGH(e,g,h)
#define DBG002_NGP(e,g,p)
#define DBG002_NHP(e,h,p)
#define DBG002_NGHP(e,g,h,p)
#define DBG002_ID(e)
#define DBG002_IS(e)
#define DBG002_ISG(e,g)
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status)
#define DBG002_FUNCTION_EXIT(GID, Status)

#endif/* End of defintions of dummy Debug Log macros*/
<% } %>

/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/
#define APP_GID DBG002_GID_ADC004

/**
 * @cond INTERNAL_DOCS
 */
/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/

/*******************************************************************************
**                 Private Function Declarations:
*******************************************************************************/
/**
 * @brief This function initialises  the app.
 *
 * @param [in] HandlePtr pointer to the Instance variable<BR>
 *
 * @return  NOne <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */

void ADC004_lInit(const ADC004_HandleType *HandlePtr );
/**
 * @brief This function Initialises the Sample and hold sequencer.
 * <b>Reentrant: yes</b><BR>
 * <b>Sync/Async:  Synchronous</b>
 *
 */
void SampleHoldSequencer_Init(const ADC004_HandleType *HandlePtr);


/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/

/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/

/*******************************************************************************
**                      Private Constant Definitions                          **
*******************************************************************************/

/*******************************************************************************
**                 Function like macro definitions                            **
*******************************************************************************/

/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/

/** This function initializes the app */
void ADC004_Init(void)
{
  /*Initialize the global app */
  ADCGLOB001_Init();

  /*Initialize the sample and hold sequencer */
  SampleHoldSequencer_Init(&ADC004_Handle0);

  /*Initialize the ADC */
  ADC004_lInit(&ADC004_Handle0);
}

/*******************************************************************************
**    Sample and Hold Sequencer  Initialization Function                      **
*******************************************************************************/
void SampleHoldSequencer_Init(const ADC004_HandleType *HandlePtr){
    uint32_t i=100UL;
/* Pointer to the VADC Kernel Structure */
    SHS_Type *SHSPtr;

    SHSPtr = HandlePtr->SHSPtr;

    SHSPtr->SHSCFG = (((0x1UL << ((uint32_t)SHS_SHSCFG_SCWC_Pos))\
        & ((uint32_t)SHS_SHSCFG_SCWC_Msk))\
        | (((uint32_t)HandlePtr->kAnaControl << (uint32_t)SHS_SHSCFG_ANOFF_Pos)\
        & (uint32_t)SHS_SHSCFG_ANOFF_Msk)\
        | (((uint32_t)HandlePtr->kAnaRef << (uint32_t)SHS_SHSCFG_AREF_Pos)\
        & (uint32_t)SHS_SHSCFG_AREF_Msk));

    while(--i){}
    SHSPtr->GNCTR00 =
    ((((uint32_t)HandlePtr->kGainG0Ch0 << (uint32_t)SHS_GNCTR00_GAIN0_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN0_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch1 << (uint32_t)SHS_GNCTR00_GAIN1_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN1_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch2 << (uint32_t)SHS_GNCTR00_GAIN2_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN2_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch3 << (uint32_t)SHS_GNCTR00_GAIN3_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN3_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch4 << (uint32_t)SHS_GNCTR00_GAIN4_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN4_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch5 << (uint32_t)SHS_GNCTR00_GAIN5_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN5_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch6 << (uint32_t)SHS_GNCTR00_GAIN6_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN6_Msk)|\
     (((uint32_t)HandlePtr->kGainG0Ch7 << (uint32_t)SHS_GNCTR00_GAIN7_Pos)\
     & (uint32_t)SHS_GNCTR00_GAIN7_Msk));

    SHSPtr->GNCTR10 =
    ((((uint32_t)HandlePtr->kGainG1Ch0 << (uint32_t)SHS_GNCTR10_GAIN0_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN0_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch1 << (uint32_t)SHS_GNCTR10_GAIN1_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN1_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch2 << (uint32_t)SHS_GNCTR10_GAIN2_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN2_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch3 << (uint32_t)SHS_GNCTR10_GAIN3_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN3_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch4 << (uint32_t)SHS_GNCTR10_GAIN4_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN4_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch5 << (uint32_t)SHS_GNCTR10_GAIN5_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN5_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch6 << (uint32_t)SHS_GNCTR10_GAIN6_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN6_Msk)|\
     (((uint32_t)HandlePtr->kGainG1Ch7 << (uint32_t)SHS_GNCTR10_GAIN7_Pos)\
     & (uint32_t)SHS_GNCTR10_GAIN7_Msk));

    SHSPtr->LOOP =
    ((((uint32_t)HandlePtr->kLoopen0 <<(uint32_t)SHS_LOOP_LPEN0_Pos)\
     & (uint32_t)SHS_LOOP_LPEN0_Msk)|\
     (((uint32_t)HandlePtr->kGroupLoop0 << (uint32_t)SHS_LOOP_LPSH0_Pos)\
     & (uint32_t)SHS_LOOP_LPSH0_Msk)|\
     (((uint32_t)HandlePtr->kChLoop0 << (uint32_t)SHS_LOOP_LPCH0_Pos)\
     & (uint32_t)SHS_LOOP_LPCH0_Msk)|\
     (((uint32_t)HandlePtr->kLoopen1 << (uint32_t)SHS_LOOP_LPEN1_Pos)\
     & (uint32_t)SHS_LOOP_LPEN1_Msk)|\
     (((uint32_t)HandlePtr->kGroupLoop1 << (uint32_t)SHS_LOOP_LPSH1_Pos)\
     & (uint32_t)SHS_LOOP_LPSH1_Msk)|\
     (((uint32_t)HandlePtr->kChLoop1 << (uint32_t)SHS_LOOP_LPCH1_Pos)\
     & (uint32_t)SHS_LOOP_LPCH1_Msk));

} /* end of void SampleHoldSequencer_Init()*/

/*
 * This Function initializes the ADC004 App.
 */
void ADC004_lInit(const ADC004_HandleType *HandlePtr )
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if((HandlePtr->DynamicHandlePtr->State == ADC004_UNINITIALIZED))
  {

    /* Wait for read mode */
    WR_REG( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_WFR_Msk,
            VADC_GLOBRCR_WFR_Pos, (uint32_t)HandlePtr->kResultReadMode);

    /* Result event service request  */
    WR_REG( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Msk,
            VADC_GLOBRCR_SRGEN_Pos, (uint32_t)HandlePtr->kResultEvtEnable);

    /* Select the input channels sequence */
    VADCGlobalPtr->BRSSEL[0] =  HandlePtr->kGroup0ChSelect;
    VADCGlobalPtr->BRSSEL[1] =  HandlePtr->kGroup1ChSelect;

    /*
     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written
     * Selects trigger mode .
     */
    VADCGlobalPtr->BRSCTRL |=
                (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos) |  \
                ((uint32_t)HandlePtr->kTriggerMode << VADC_BRSCTRL_XTMODE_Pos));

    /*
     * Selects the gating mode and enables trigger mode.
     * AutoScan enable or disable
     * Source interrupt enable or disable
     */
    VADCGlobalPtr->BRSMR |=
        (uint32_t)(((uint32_t)HandlePtr->kTriggerEn << VADC_BRSMR_ENTR_Pos) | \
        ((uint32_t)HandlePtr->kGatingMode  << VADC_BRSMR_ENGT_Pos) |   \
        ((uint32_t)HandlePtr->kAutoScan << VADC_BRSMR_SCAN_Pos) |   \
        ((uint32_t)HandlePtr->kResourceEvtEnable << VADC_BRSMR_ENSI_Pos));

    /* change the state to 'Initialized' */
    HandlePtr->DynamicHandlePtr->State = ADC004_INITIALIZED;
    Status &= (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
}

/**
 * This function resets the App.
 */
status_t ADC004_Deinit(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if((HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED))
  {
    VADCGlobalPtr->GLOBRCR = (uint32_t )0;

    /* Select the input channels sequence */
    VADCGlobalPtr->BRSSEL[0] =  (uint32_t )0;
    VADCGlobalPtr->BRSSEL[1] =  (uint32_t )0;
    VADCGlobalPtr->BRSCTRL = (uint32_t )0x00808000;

    VADCGlobalPtr->BRSMR = (uint32_t )0;
    Status = (uint32_t)DAVEApp_SUCCESS;
    HandlePtr->DynamicHandlePtr->State = ADC004_UNINITIALIZED;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function enables the service request after result event.
 */
status_t ADC004_EnableResultEvt(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    /* Enable Result event service request  */
    SET_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the service request after result event.
 */
status_t ADC004_DisableResultEvt(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    /* Disables Result event service request  */
    CLR_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function returns the result of the normal mode ADC conversion.
 */
status_t ADC004_GetResult(const ADC004_HandleType* HandlePtr,
                                            ADC004_ResultHandleType* ResultPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  uint32_t ADCResult;

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(ResultPtr != NULL)
    {
      ADCResult = VADCGlobalPtr->GLOBRES;
      /* If valid flag is set */
      if(((ADCResult & VADC_GLOBRES_VF_Msk)>>VADC_GLOBRES_VF_Pos)==(uint32_t)1)
      {
        ResultPtr->GroupNo =
          (uint8_t)((ADCResult & VADC_GLOBRES_GNR_Msk)>>VADC_GLOBRES_GNR_Pos);
        ResultPtr->ChannelNo =
          (uint8_t)((ADCResult & VADC_GLOBRES_CHNR_Msk)>>VADC_GLOBRES_CHNR_Pos);
        ResultPtr->Result =
          (uint16_t)(ADCResult & VADC_GLOBRES_RESULT_Msk);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      /* If data is old, then send error as invalid data */
      else
      {
        Status = (uint32_t)ADC004_INVALID_RESULT;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function reads the result of the normal mode ADC conversion
 * without checking the valid bitfield.
 */
 status_t ADC004_GetFastResult(const ADC004_HandleType* HandlePtr,
                               uint16_t *Result)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    *Result = (uint16_t)(VADCGlobalPtr->GLOBRES &
                        (uint32_t)VADC_GLOBRES_RESULT_Msk);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function checks whether Result event flag is set.
 */
status_t ADC004_GetResultEvtFlag(const ADC004_HandleType* HandlePtr,
                                                            uint8_t* EvtStatus)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    if(EvtStatus != NULL)
    {
      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG,
                          VADC_GLOBEFLAG_REVGLB_Msk, VADC_GLOBEFLAG_REVGLB_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This will set the result event flag through software.
 */
status_t ADC004_SetResultEvtFlag(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG, VADC_GLOBEFLAG_REVGLB_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function clears the pending result event flag
 */
status_t ADC004_ClearResultEvtFlag(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG, VADC_GLOBEFLAG_REVGLBCLR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}



/**
 * This function enables the service request after background request
 * source event.
 */
status_t ADC004_EnableBackGroundEvent(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    /* Enable background request source event service request  */
    SET_BIT( VADCGlobalPtr->BRSMR, VADC_BRSMR_ENSI_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the service request after background request
 * source event.
 */
status_t ADC004_DisableBackGroundEvent(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    /* Disable background request source event service request */
    CLR_BIT( VADCGlobalPtr->BRSMR, VADC_BRSMR_ENSI_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function checks whether source event flag is set.
 */
status_t ADC004_GetBackGroundEvtFlag(const ADC004_HandleType* HandlePtr,
                                                            uint8_t* EvtStatus)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(EvtStatus != NULL)
    {
      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG,
                                    VADC_GLOBEFLAG_SEVGLB_Msk,
                                    VADC_GLOBEFLAG_SEVGLB_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function sets the source event flag through software.
 */
status_t ADC004_SetBackGroundEvtFlag(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG, VADC_GLOBEFLAG_SEVGLB_Pos );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function clears the pending source event flag.
 */
status_t ADC004_ClearBackGroundEvtFlag(const ADC004_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC004_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG, VADC_GLOBEFLAG_SEVGLBCLR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/* This function clears pending bits.*/
status_t ADC004_ClearPendingBits(const ADC004_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    /* Clear Pending Bits */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_CLRPND_Pos);

    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/* This function generates a load event.*/
status_t ADC004_GenerateLoadEvent(const ADC004_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    /* Generate load event */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDEV_Pos);

    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function enables the gating.
 */
status_t ADC004_EnableGate(const ADC004_HandleType *HandlePtr,
                           uint8_t GateSelectVal)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(GateSelectVal <= (uint8_t)ADC004_GATING_ENABLED_FOR_LOW)
    {
      /* Selects the gating functionality */
     WR_REG(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENGT_Msk, VADC_BRSMR_ENGT_Pos,
                                                      (uint8_t)GateSelectVal);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function gives the selected gate input level.
 */
status_t ADC004_GetGateLevel(const ADC004_HandleType* HandlePtr,
                             uint8_t* GeteLvlPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(GeteLvlPtr != NULL)
    {
      *GeteLvlPtr = (uint8_t)RD_REG( VADCGlobalPtr->BRSMR, VADC_BRSMR_REQGT_Msk,
                                     VADC_BRSMR_REQGT_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function sets the external trigger mode.
 */
status_t ADC004_SetExternalTriggerMode(const ADC004_HandleType *HandlePtr,
                                                         uint8_t TriggerMode)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  uint32_t ModeSelect;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(TriggerMode <= (uint8_t)ADC004_TRIGGER_UPON_BOTH_EDGE)
    {
      if(TriggerMode == (uint8_t)ADC004_NOTRIGGER)
      {
        /* Disables external trigger */
        CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
      }
      else
      {
        /* Enables external trigger */
        SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
      }
      /* Sets the external trigger mode */
      ModeSelect = VADCGlobalPtr->BRSCTRL;
      ModeSelect &= ~VADC_BRSCTRL_XTMODE_Msk;
      ModeSelect |= (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos) |
                ((uint32_t)TriggerMode << VADC_BRSCTRL_XTMODE_Pos));
      VADCGlobalPtr->BRSCTRL = ModeSelect;
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function enables external trigger.
 */
status_t ADC004_EnableExternalTrigger(const ADC004_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    /* Enables external trigger */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function disables external trigger.
 */
status_t ADC004_DisableExternalTrigger(const ADC004_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    /* Disables external trigger */
    CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function sets the Autoscan Source Load Event Mode.
 * Overwrite Mode or Combine Mode can be selected.
 */
status_t ADC004_SetLoadEventMode(const ADC004_HandleType *HandlePtr,
                                                            uint8_t EventMode)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(EventMode == (uint8_t)ADC004_OVERWRITE_MODE)
    {
      /* Set OverWrite Mode */
      CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else if(EventMode == (uint8_t)ADC004_COMBINE_MODE)
    {
      /* Set Combine Mode */
      SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function sets the required channel in channel pending register.
 */
status_t ADC004_SetPendingChannel(const ADC004_HandleType *HandlePtr,
                                  const ADC004_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC004_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC004_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) && (ChannelNoAct == (uint8_t)1))
      {
        /*set the channel*/
        SET_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 * This function clears the required channel in channel pending register.
 */
status_t ADC004_ClearPendingChannel(const ADC004_HandleType *HandlePtr,
                                    const ADC004_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC004_MAX_ADC_GROUP) &&
            (ChannelNo <= (uint8_t)ADC004_MAX_ADC_GROUP_CHANNEL) &&
              (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))
      {
        /*Set the channel*/
        CLR_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 *This function sets the required channel in channel pending register.
 */
status_t ADC004_SetChannelSelect(const ADC004_HandleType *HandlePtr,
                                 const ADC004_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC004_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC004_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))
      {
        /*set the channel*/
        SET_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 * This function clears the required channel in channel pending register.
 */
status_t ADC004_ClearChannelSelect(const ADC004_HandleType *HandlePtr,
                                   const ADC004_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC004_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC004_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC004_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC004_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) &&
              (ChannelNoAct == (uint8_t)1))
      {
        /*Set the channel*/
        CLR_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC004_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * @endcond
 */
/*CODE_BLOCK_END*/
